(define (test-report-fail-backgammon bg dices paths)
  (format #t "  board: ~s~%" bg)
  (format #t "  dices: ~s~%" dices)
  (loop-for path in paths do
    (format #t " - path: ~s~%" path)))


(define (odd-dices)
  (let ((dices #f)
        (ok #f))
    (do ()
        (ok)
      (set! dices (roll-dices))
      (if (not (= (car dices) (cadr dices)))
          (set! ok #t)))
    dices))

(define (dices->pos dices)
  (match dices
    ((a b)
     (if (= a b) (* a 4) (+ a b)))))

(define-test (test-backgammon-path-edge)
  (let ((bg (setup-bg)))
    (array-zero! (bg-b-pts bg))
    (array-zero! (bg-w-pts bg))
    (array-inc! (bg-w-pts bg)  0 1)
    (array-inc! (bg-b-pts bg) 23 1)
    (let* ((dices (odd-dices))
           (paths (bg-find-all-states bg dices)))
      (test-assert (= (length paths) 1)
                   (lambda ()
                     (format #t "expected 1 feasible path, got ~a~%" (length paths))
                     (test-report-fail-backgammon bg dices paths))))))

(define-test (test-backgammon-path-1mv)
  (let ((bg (setup-bg)))
    (array-zero! (bg-b-pts bg))
    (loop-subtests (i)
      (array-zero! (bg-w-pts bg))
      (array-inc! (bg-w-pts bg) (+ 6 (random 8)) 1)
      (let* ((dices (odd-dices))
             (paths (bg-find-all-states bg dices)))
        (test-assert (= (length paths) 1)
                     (lambda ()
                       (format #f "expected 1 feasible path, got ~a~%" (length paths))
                       (test-report-fail-backgammon bg dices paths)))))))

(define-test (test-backgammon-path-2mv)
  (let ((bg (setup-bg)))
    (array-zero! (bg-b-pts bg))
    (loop-subtests (i)
      (array-zero! (bg-w-pts bg))
      (array-inc! (bg-w-pts bg) (+ 12 (random 8)) 1)
      (array-inc! (bg-w-pts bg) (+ 12 (random 8)) 1)
      (let* ((dices (odd-dices))
             (paths (bg-find-all-states bg dices)))
        (test-assert (> (length paths) 1)
                     (lambda ()
                       (format #f "expected >1 feasible paths, got ~a~%" (length paths))
                       (test-report-fail-backgammon bg dices paths)))))))

(define (_test-backgammon-bar-pos_ ply)
  (let* ((bg (setup-bg))
         (dices (odd-dices))
         (pos (dices->pos dices)))
    (set-bg-ply! bg ply)
    (array-zero! (bg-b-pts bg))
    (array-zero! (bg-w-pts bg))
    (cond
     (ply
      (set-bg-w-bar! bg 1)
      (set-bg-w-rem! bg 14))
     (else
      (set-bg-b-bar! bg 1)
      (set-bg-b-rem! bg 14)))
    (let ((paths (bg-find-all-states bg dices)))
        (test-assert (= (length paths) 1)
                     (lambda ()
                       (format #f "expected 1 feasible path, got ~a~%" (length paths))
                       (test-report-fail-backgammon bg dices paths)))
        (let ((bg2 (car paths)))
          (cond
           (ply
            (array-for-each (lambda (x) (assert (= x 0)))
                            (bg-b-pts bg2))
            (loop-array (lambda (i x)
                          (if (= i (- 24 pos))
                             (test-assert (= x 1) "white-wrong-1-pos")
                             (test-assert (= x 0) "white-wrong-0-pos")))
                        (bg-w-pts bg2)))
           (else
            (array-for-each (lambda (x) (assert (= x 0)))
                            (bg-w-pts bg2))
            (loop-array (lambda (i x)
                          (if (= i (1- pos))
                             (test-assert (= x 1) "black-wrong-1-pos")
                             (test-assert (= x 0) "black-wrong-0-pos")))
                        (bg-b-pts bg2))))))))


(define-test (test-backgammon-bar-pos)
  (let ((bg (setup-bg)))
    (loop-subtests (i)
      (_test-backgammon-bar-pos_ #t)
      (_test-backgammon-bar-pos_ #f))))

(define (_test-backgammon-state-valid bg)
  (match (pts-ply bg)
    ((arr brr)
     (do ((p 0 (1+ p)))
         ((>= p 24))
       ; same point musn't be occupied by both players
       (assert (not (and (> (array-ref arr p) 0)
                         (> (array-ref brr p) 0))))))))

(define (_test-backgammon-run-game pre-step-fun move-fun)
  (let* ((bg (setup-bg))
         (dices (odd-dices))
         (pos (dices->pos dices))
         (terminal-state #f)
         (ply #t)) ; white begin
      (do ((step 0 (1+ step)))
          (terminal-state)
        (pre-step-fun bg step)
        (match (move-fun bg (roll-dices))
          (#f ; player cant move
           (test-assert (not (state-terminal? bg))))
          (new-bg
           (set! terminal-state (state-terminal? new-bg))
           (set! bg new-bg)
           (set-bg-ply! bg ply))))))

(define-test (test-backgammon-valid-pos)
  (let ((pre-step-fun (lambda (bg step)
                        (_test-backgammon-state-valid bg)))
        (move-fun (lambda (bg dices)
                    (let ((paths (bg-find-all-states bg dices)))
                      (loop-for bg in paths do
                        (_test-backgammon-state-valid bg))
                      (list-ref paths (random (length paths)))))))
    (loop-subtests (i)
      (_test-backgammon-run-game pre-step-fun move-fun))))

(define-test (test-backgammon-path-dual)
  (let ((bg (setup-bg)))
    (array-zero! (bg-w-pts bg))
    (array-zero! (bg-b-pts bg))
    (array-inc! (bg-w-pts bg) 5 1)
    (array-inc! (bg-b-pts bg) 13 1)
    (_test-backgammon-state-valid bg)
    (let ((paths (bg-find-all-states bg (list 2 4))))
      (test-assert (= (length paths) 1)
                   (lambda ()
                     (format #f "wrong number of paths: ~a, expected 1~%" (length paths))
                     (test-report-fail-backgammon bg (list 2 4) paths))))
    (array-inc! (bg-b-pts bg) 3 1)
    (let ((paths (bg-find-all-states bg (list 2 4))))
      (test-assert (= (length paths) 2)
                   (lambda ()
                     (format #f "wrong number of paths: ~a, expected 2~%" (length paths))
                     (test-report-fail-backgammon bg (list 2 4) paths))))))

(define-test (test-backgammon-remove-pts)
  (let ((bg (setup-bg)))
    ;
    (array-zero! (bg-w-pts bg))
    (array-zero! (bg-b-pts bg))
    (array-inc! (bg-w-pts bg) 3 1)
    (array-inc! (bg-w-pts bg) 23 1)
    (_test-backgammon-state-valid bg)
    (let ((paths (bg-find-all-states bg (list 4 4))))
      (test-assert (= (length paths) 1)
                   (lambda ()
                     (format #f "wrong number of paths: ~a, expected 1~%" (length paths))
                     (test-report-fail-backgammon bg (list 4 4) paths)))
      (loop-for bg in paths do
        (assert (= (bg-w-rem bg) 0) "white-removed!")))
    ;
    (array-zero! (bg-w-pts bg))
    (array-inc! (bg-w-pts bg) 3 1)
    (_test-backgammon-state-valid bg)
    (let ((paths (bg-find-all-states bg (list 4 4))))
      (test-assert (= (length paths) 1)
                   (lambda ()
                     (format #t "wrong number of paths: ~a, expected 1~%" (length paths))
                     (test-report-fail-backgammon bg (list 4 4) paths))))
    ;
    (set-bg-ply! bg #f) ; blacks turn
    (array-zero! (bg-w-pts bg))
    (array-zero! (bg-b-pts bg))
    (array-inc! (bg-b-pts bg) 16 1)
    (array-inc! (bg-b-pts bg) 23 1)
    (_test-backgammon-state-valid bg)
    (let ((paths (bg-find-all-states bg (list 1 2))))
      (test-assert (= (length paths) 2)
                   (lambda ()
                     (format #t "wrong number of paths: ~a, expected 2~%" (length paths))
                     (test-report-fail-backgammon bg (list 1 2) paths)))
      (let ((totrem 0))
        (loop-for path in paths do
          (set! totrem (+ totrem (bg-b-rem path))))
        (assert (= totrem 1)
                (lambda ()
                  (format #t "black-removed, got ~a, expected ~a~%" totrem 1)
                  (test-report-fail-backgammon bg (list 1 2) paths)))))))

(define (bg-print-paths paths)
  (let ((i 0))
    (loop-for path in paths do
          (let* ((safe (bg-safe? path #f))
                 (bar  (> (bg-w-bar path) 0))
                 (rem  (> (bg-b-rem path) 0))
                 (prip (lambda ()
                         (format #t "~a ~a~a~a: [w b:~s r:~s] [b b:~s r:~s] {" i
                                 (if safe "s" " ")
                                 (if bar  "b" " ")
                                 (if rem  "r" " ")
                                 (bg-w-bar path)
                                 (bg-w-rem path)
                                 (bg-b-bar path)
                                 (bg-b-rem path))
                         (do ((p 0 (1+ p)))
                             ((>= p 24))
                           (let ((pts (array-ref (bg-w-pts path) p)))
                             (if (= 0 pts)
                               (format #t ".")
                               (format #t "~a" pts))))
                         (format #t "} {")
                         (do ((p 0 (1+ p)))
                             ((>= p 24))
                           (let ((pts (array-ref (bg-b-pts path) p)))
                             (if (= 0 pts)
                               (format #t ".")
                               (format #t "~a" pts))))
                         (format #t "} ~a~%" i))))
          (prip)
          (set! i (1+ i))))))

(define-test (test-backgammon-bar)
  (let ((bg (setup-bg)))
    (array-zero! (bg-w-pts bg))
    (array-zero! (bg-b-pts bg))
    (array-inc! (bg-b-pts bg) 18 2)
    (set-bg-w-bar! bg 1)
    (_test-backgammon-state-valid bg)
    (let* ((dices (list 2 6))
           (paths (bg-find-all-states bg dices)))
      ;(bg-print-paths paths)
      (test-assert (= (length paths) 1)
                   (lambda ()
                     (format #t "expected 1 feasible path, got ~a~%" (length paths))
                     (test-report-fail-backgammon bg dices paths)))
      (test-assert (= (array-ref (bg-w-pts (car paths)) (- 24 8)) 1)
                   (lambda ()
                     (format #t "expected a white-point at ~a~%" (- 24 8)))))))
